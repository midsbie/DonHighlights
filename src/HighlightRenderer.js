// @flow

import TextContent from "./TextContent";
import type { RangeDescriptor } from "./TextRange";
import TextNodeVisitor from "./TextNodeVisitor";
import HighlightDecorator from "./HighlightDecorator";
import Highlight from "./Highlight";

/**
 * Return boolean value indicative of whether a given node is a highlight container
 * @access private
 *
 * @param {Node | Element | EventTarget} node - DOM node or element to check
 * @returns {boolean} `true` if it is a highlight container
 */
export function isHighlight(node: Node | Element | EventTarget): boolean {
  // This is potentially problematic if the document uses a data attribute of the same name.  We
  // should introduce some sort of signature that is randomly generated by the parent DOM
  // Highlighter instance and which all highlight elements are expected to carry.
  return node.nodeType === 1 && (node: any).dataset.dhHighlight === "true";
}

export default class HighlightRenderer {
  content: TextContent;
  decorator: HighlightDecorator;

  constructor(content: TextContent, decorator: HighlightDecorator) {
    this.content = content;
    this.decorator = decorator;
  }

  /**
   * Highlight a range
   *
   * Highlights a given range by wrapping one or more text nodes with a `span` tag and applying a
   * particular CSS class.
   *
   * @param {string} className - The CSS class name to apply
   */
  surround(highlight: Highlight): Array<HTMLElement> {
    const { start: rangeStart, end: rangeEnd } = highlight.range;
    let elements = [];
    if (rangeStart.marker.node === rangeEnd.marker.node) {
      // Optimised case: highlighting does not span multiple nodes
      elements.push(this._surround(rangeStart, rangeStart.offset, rangeEnd.offset));
    } else {
      // Highlighting spans 2 or more nodes, which means we need to build a representation of all the
      // text nodes contained in the start to end range, but excluding the start and end nodes
      const visitor = new TextNodeVisitor(rangeStart.marker.node, this.content.root);
      const end = rangeEnd.marker.node;
      const coll = [];
      // TODO: we assume `visitor.next()' will never return null because `endÂ´ is within bounds
      while (visitor.next() !== end) {
        coll.push((visitor.current: any));
      }

      // Apply highlighting to start and end nodes, and to any nodes in between, if applicable.
      // Highlighting for the start and end nodes may require text node truncation but not for the
      // nodes in between.
      elements.push(this._surround(rangeStart, rangeStart.offset, null));
      // $FlowFixMe: unclear what the error is about; array is cleaned below anyhow.
      coll.forEach((n) => elements.push(this._surroundWhole(n)));
      elements.push(this._surround(rangeEnd, 0, rangeEnd.offset));
    }

    elements = elements.filter(Boolean);
    if (elements.length > 0) {
      highlight.range.clearStartOffset();
      // $FlowFixMe: guaranteed not to contain nulls
      this.decorator.decorate(elements, highlight);
    }
    // $FlowFixMe: guaranteed not to contain nulls
    return elements;
  }

  decorate(highlight: Highlight): void {
    this.decorator.decorate(highlight.elements, highlight);
  }

  //  Private interface
  // ----------------------------------------
  /**
   * Truncate text node and apply highlighting
   *
   * Truncates text node into 2 or 3 text nodes and apply highlighting to relevant node, which is
   * always the node referenced by `descr.marker.node`.
   *
   * @param {Object} descr - Start or end `Range` descriptor
   * @param {number} start - Start offset
   * @param {number | null} end - End offset
   * @param {string} className - CSS class name to apply
   *
   * @returns {?HTMLElement} Highlight element
   */
  _surround(descr: RangeDescriptor, start: number, end: number | null): HTMLElement {
    this.content.truncate(
      descr.marker,
      start,
      end == null ? descr.marker.node.nodeValue.length - 1 : end
    );
    // $FlowFixMe: always returning a highlight element
    return this._createHighlightElement(descr.marker.node, true);
  }

  /**
   * Apply highlighting fully to a text node
   *
   * No text node truncation occurs.
   *
   * @param {Node} node - Text node to apply highlighting to
   * @param {string} className - CSS class name to apply
   *
   * @returns {?HTMLElement} Highlight element
   * */
  _surroundWhole(node: Node): ?HTMLElement {
    return this._createHighlightElement(node);
  }

  _createHighlightElement(node: Node, force?: boolean): ?HTMLElement {
    if (!force && node.nodeValue.trim().length < 1) return null;

    const span = document.createElement("span");
    // Stamp the highlight element with a data attribute that is expected to be unique to
    // highlights produced by Don Highlights instances and which enables `XPathResolver` instances
    // to identify highlight elements when computing the _true_ XPath representation of an
    // arbitrary selection.  This is because it is not desirable at all for the computed XPath
    // representation to include highlight elements created by Don Highlights.
    //
    // This is potentially problematic if the document uses a data attribute of the same name.  We
    // should introduce some sort of signature that is randomly generated by the parent DOM
    // Highlighter instance and which all highlight elements are expected to carry.
    span.dataset.dhHighlight = "true";
    (node.parentNode: any).insertBefore(span, node);
    span.appendChild(node);
    return span;
  }
}
